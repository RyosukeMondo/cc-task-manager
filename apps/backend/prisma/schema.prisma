// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model aligned with existing auth schemas
model User {
  id        String     @id @default(uuid())
  email     String     @unique
  password  String // bcrypt hash
  name      String? // optional name field
  username  String?    @unique
  firstName String?    @map("first_name")
  lastName  String?    @map("last_name")
  role      UserRole   @default(USER)
  status    UserStatus @default(ACTIVE)

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at") // soft delete support
  lastLoginAt DateTime? @map("last_login_at")

  // Relationships
  createdTasks  Task[]       @relation("TaskCreator")
  assignedTasks Task[]       @relation("TaskAssignee")
  claudeTasks   ClaudeTask[] @relation("ClaudeTaskCreator")
  apiTasks      ApiTask[]    @relation("ApiTaskCreator")
  sessions      Session[]
  settings      Settings?

  @@index([email])
  @@map("users")
}

// User role enumeration matching auth schemas
enum UserRole {
  ADMIN
  USER
  MODERATOR

  @@map("user_role")
}

// User status enumeration matching auth schemas
enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  PENDING_VERIFICATION

  @@map("user_status")
}

// =============================================================================
// USER SETTINGS - User preferences and configuration
// =============================================================================

// Settings model for user preferences
model Settings {
  id             String         @id @default(uuid())
  userId         String         @unique @map("user_id")
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  theme          Theme          @default(SYSTEM)
  notifications  Boolean        @default(true)
  displayDensity DisplayDensity @default(COMFORTABLE) @map("display_density")
  language       String         @default("en")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([userId])
  @@map("settings")
}

// Theme enumeration for display preferences
enum Theme {
  LIGHT
  DARK
  SYSTEM

  @@map("theme")
}

// Display density enumeration for UI spacing
enum DisplayDensity {
  COMFORTABLE
  COMPACT
  SPACIOUS

  @@map("display_density")
}

// Task model aligned with existing task schemas
model Task {
  id          String       @id @default(uuid())
  title       String
  description String?
  status      TaskStatus   @default(TODO)
  priority    TaskPriority @default(MEDIUM)

  // Relationships
  createdById String @map("created_by_id")
  createdBy   User   @relation("TaskCreator", fields: [createdById], references: [id], onDelete: Cascade)

  assigneeId String? @map("assignee_id")
  assignee   User?   @relation("TaskAssignee", fields: [assigneeId], references: [id], onDelete: SetNull)

  projectId String?  @map("project_id")
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  // Metadata
  tags        String[]
  dueDate     DateTime? @map("due_date")
  completedAt DateTime? @map("completed_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([assigneeId])
  @@index([projectId])
  @@index([completedAt])
  @@index([dueDate])
  // Composite indexes for task management
  @@index([status, priority])
  @@index([status, assigneeId])
  @@index([createdById, status])
  @@index([projectId, status])
  @@index([assigneeId, status])
  @@index([status, dueDate])
  // Task performance queries
  @@index([status, priority, assigneeId])
  @@index([projectId, status, priority])
  @@index([assigneeId, status, dueDate])
  @@map("tasks")
}

// Task status enumeration
enum TaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  DONE
  CANCELLED

  @@map("task_status")
}

// Task priority enumeration
enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT

  @@map("task_priority")
}

// Project model for task organization
model Project {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Relationships
  tasks       Task[]
  claudeTasks ClaudeTask[]

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("projects")
}

// Session model for JWT refresh token management
model Session {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  refreshToken String    @unique @map("refresh_token")
  expiresAt    DateTime  @map("expires_at")
  lastActive   DateTime  @default(now()) @map("last_active")
  createdAt    DateTime  @default(now()) @map("created_at")
  deletedAt    DateTime? @map("deleted_at") // soft delete for logout

  // Optional session metadata
  deviceInfo String? @map("device_info")
  ipAddress  String? @map("ip_address")
  userAgent  String? @map("user_agent")

  @@index([userId])
  @@index([refreshToken])
  @@map("sessions")
}

// =============================================================================
// CLAUDE CODE ENTITIES - Enhanced task management for AI operations
// =============================================================================

// Claude Code AI task model for intelligent task execution
model ClaudeTask {
  id          String           @id @default(uuid())
  title       String
  description String?
  prompt      String // Claude Code prompt/command
  config      Json? // Task configuration (timeout, retry, etc.)
  status      ClaudeTaskStatus @default(PENDING)
  priority    TaskPriority     @default(MEDIUM)

  // Relationships
  createdById String   @map("created_by_id")
  createdBy   User     @relation("ClaudeTaskCreator", fields: [createdById], references: [id], onDelete: Cascade)
  projectId   String?  @map("project_id")
  project     Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  // Execution tracking
  executions TaskExecution[]
  queueJobs  QueueJob[]
  results    TaskResult[]

  // Metadata
  tags              String[]
  estimatedDuration Int?     @map("estimated_duration") // seconds
  actualDuration    Int?     @map("actual_duration") // seconds

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  scheduledAt DateTime? @map("scheduled_at")
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")

  @@index([status])
  @@index([priority])
  @@index([createdById])
  @@index([scheduledAt])
  @@index([startedAt])
  @@index([completedAt])
  @@index([projectId])
  // Composite indexes for common query patterns
  @@index([status, priority])
  @@index([status, createdById])
  @@index([createdById, status])
  @@index([projectId, status])
  @@index([status, scheduledAt])
  @@index([status, startedAt])
  @@index([createdById, createdAt])
  // Performance indexes for monitoring queries
  @@index([status, completedAt, startedAt])
  @@index([createdById, status, priority])
  @@map("claude_tasks")
}

// Task execution tracking for individual execution attempts
model TaskExecution {
  id     String     @id @default(uuid())
  taskId String     @map("task_id")
  task   ClaudeTask @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Execution metadata
  status    ExecutionStatus @default(INITIALIZING)
  progress  Float?          @default(0.0) // 0.0 to 1.0
  workerId  String?         @map("worker_id")
  processId String?         @map("process_id")
  sessionId String?         @map("session_id") // Claude Code session

  // Resource tracking
  cpuUsage    Float? @map("cpu_usage")
  memoryUsage Int?   @map("memory_usage") // bytes
  diskUsage   Int?   @map("disk_usage") // bytes

  // Error handling
  errorMessage String? @map("error_message")
  errorCode    String? @map("error_code")
  stackTrace   String? @map("stack_trace")
  retryCount   Int     @default(0) @map("retry_count")

  // Relationships
  logs    ExecutionLog[]
  metrics SystemMetric[]

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  startedAt     DateTime? @map("started_at")
  completedAt   DateTime? @map("completed_at")
  lastHeartbeat DateTime? @map("last_heartbeat")

  @@index([taskId])
  @@index([status])
  @@index([workerId])
  @@index([startedAt])
  @@index([lastHeartbeat])
  @@index([completedAt])
  @@index([processId])
  @@index([sessionId])
  // Composite indexes for execution monitoring
  @@index([taskId, status])
  @@index([status, workerId])
  @@index([status, startedAt])
  @@index([workerId, status])
  @@index([taskId, status, startedAt])
  // Performance indexes for resource tracking
  @@index([status, lastHeartbeat])
  @@index([workerId, lastHeartbeat])
  @@index([status, completedAt, startedAt])
  // Monitoring dashboard queries
  @@index([status, workerId, startedAt])
  @@map("task_executions")
}

// Queue job management for BullMQ persistence
model QueueJob {
  id     String     @id @default(uuid())
  taskId String     @map("task_id")
  task   ClaudeTask @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Queue metadata
  queueName String         @map("queue_name")
  jobId     String         @unique @map("job_id") // BullMQ job ID
  status    QueueJobStatus @default(WAITING)
  priority  Int            @default(0)
  delay     Int?           @default(0) // milliseconds

  // Processing
  attempts     JobAttempt[]
  maxAttempts  Int          @default(3) @map("max_attempts")
  backoffType  BackoffType  @default(EXPONENTIAL) @map("backoff_type")
  backoffDelay Int          @default(2000) @map("backoff_delay") // milliseconds

  // Data
  jobData    Json  @map("job_data")
  jobOptions Json? @map("job_options")
  result     Json?

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  processedAt DateTime? @map("processed_at")
  finishedAt  DateTime? @map("finished_at")

  @@index([queueName])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@index([jobId])
  @@index([taskId])
  @@index([processedAt])
  @@index([finishedAt])
  // Composite indexes for queue management
  @@index([queueName, status])
  @@index([status, priority])
  @@index([queueName, priority])
  @@index([status, createdAt])
  @@index([taskId, status])
  // BullMQ optimization indexes
  @@index([queueName, status, priority])
  @@index([status, delay, priority])
  @@index([queueName, createdAt])
  // Queue performance monitoring
  @@index([status, processedAt])
  @@index([queueName, status, createdAt])
  @@map("queue_jobs")
}

// Job attempt tracking for retry mechanisms
model JobAttempt {
  id         String   @id @default(uuid())
  queueJobId String   @map("queue_job_id")
  queueJob   QueueJob @relation(fields: [queueJobId], references: [id], onDelete: Cascade)

  // Attempt metadata
  attemptNumber Int           @map("attempt_number")
  status        AttemptStatus @default(PROCESSING)
  error         String?
  result        Json?

  // Timestamps
  startedAt  DateTime  @map("started_at")
  finishedAt DateTime? @map("finished_at")

  @@index([queueJobId])
  @@index([attemptNumber])
  @@index([status])
  @@index([startedAt])
  @@index([finishedAt])
  // Composite indexes for attempt tracking
  @@index([queueJobId, attemptNumber])
  @@index([queueJobId, status])
  @@index([status, startedAt])
  @@index([queueJobId, status, attemptNumber])
  @@map("job_attempts")
}

// Execution log storage for Claude Code STDIO output
model ExecutionLog {
  id          String        @id @default(uuid())
  executionId String        @map("execution_id")
  execution   TaskExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)

  // Log metadata
  level   LogLevel  @default(INFO)
  source  LogSource @default(SYSTEM)
  message String
  details Json? // Structured log data

  // Context
  component     String? // Which component generated the log
  operation     String? // What operation was being performed
  correlationId String? @map("correlation_id")

  // Timestamps
  timestamp DateTime @default(now())

  @@index([executionId])
  @@index([level])
  @@index([source])
  @@index([timestamp])
  @@index([correlationId])
  @@index([component])
  @@index([operation])
  // Composite indexes for log querying
  @@index([executionId, level])
  @@index([executionId, timestamp])
  @@index([level, timestamp])
  @@index([source, level])
  @@index([correlationId, timestamp])
  // Log analysis and monitoring
  @@index([executionId, level, timestamp])
  @@index([source, level, timestamp])
  @@index([component, level, timestamp])
  // Error tracking and debugging
  @@index([level, source, timestamp])
  @@map("execution_logs")
}

// System metrics for performance monitoring
model SystemMetric {
  id          String         @id @default(uuid())
  executionId String?        @map("execution_id")
  execution   TaskExecution? @relation(fields: [executionId], references: [id], onDelete: Cascade)

  // Metric metadata
  metricType MetricType @map("metric_type")
  metricName String     @map("metric_name")
  value      Float
  unit       String?

  // Context
  workerId  String? @map("worker_id")
  queueName String? @map("queue_name")
  tags      Json? // Additional metric tags

  // Timestamps
  timestamp DateTime @default(now())

  @@index([metricType])
  @@index([metricName])
  @@index([timestamp])
  @@index([workerId])
  @@index([executionId])
  @@index([queueName])
  // Composite indexes for metrics querying
  @@index([metricType, metricName])
  @@index([metricType, timestamp])
  @@index([metricName, timestamp])
  @@index([workerId, timestamp])
  @@index([executionId, timestamp])
  // Performance monitoring queries
  @@index([metricType, metricName, timestamp])
  @@index([workerId, metricType, timestamp])
  @@index([executionId, metricType, timestamp])
  // Resource usage analytics
  @@index([metricType, workerId, timestamp])
  @@index([queueName, metricType, timestamp])
  @@map("system_metrics")
}

// Task result storage for execution outcomes
model TaskResult {
  id     String     @id @default(uuid())
  taskId String     @map("task_id")
  task   ClaudeTask @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Result metadata
  status  ResultStatus @default(SUCCESS)
  summary String?
  output  Json? // Structured output data

  // File attachments
  files ResultFile[]

  // Quality metrics
  executionTime Int?   @map("execution_time") // milliseconds
  tokensUsed    Int?   @map("tokens_used")
  costEstimate  Float? @map("cost_estimate")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  @@index([taskId])
  @@index([status])
  @@index([createdAt])
  // Composite indexes for result querying
  @@index([taskId, status])
  @@index([status, createdAt])
  @@index([taskId, createdAt])
  // Performance analysis queries
  @@index([taskId, status, createdAt])
  @@map("task_results")
}

// Result file attachments for task outputs
model ResultFile {
  id       String     @id @default(uuid())
  resultId String     @map("result_id")
  result   TaskResult @relation(fields: [resultId], references: [id], onDelete: Cascade)

  // File metadata
  filename    String
  contentType String @map("content_type")
  size        Int // bytes
  path        String // Storage path or URL
  checksum    String // File integrity verification

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  @@index([resultId])
  @@index([filename])
  @@index([contentType])
  @@index([size])
  // Composite indexes for file management
  @@index([resultId, filename])
  @@index([contentType, size])
  @@index([resultId, contentType])
  // File search and organization
  @@index([filename, contentType])
  @@index([resultId, createdAt])
  @@map("result_files")
}

// =============================================================================
// CLAUDE CODE ENUMERATIONS - Status and type definitions
// =============================================================================

// Claude task status enumeration
enum ClaudeTaskStatus {
  PENDING
  QUEUED
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
  PAUSED

  @@map("claude_task_status")
}

// Task execution status enumeration
enum ExecutionStatus {
  INITIALIZING
  STARTING
  RUNNING
  PAUSED
  COMPLETED
  FAILED
  CANCELLED
  TIMEOUT

  @@map("execution_status")
}

// Queue job status enumeration
enum QueueJobStatus {
  WAITING
  ACTIVE
  COMPLETED
  FAILED
  DELAYED
  PAUSED
  STUCK

  @@map("queue_job_status")
}

// Job attempt status enumeration
enum AttemptStatus {
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED

  @@map("attempt_status")
}

// Backoff strategy enumeration
enum BackoffType {
  FIXED
  EXPONENTIAL
  LINEAR

  @@map("backoff_type")
}

// Log level enumeration
enum LogLevel {
  TRACE
  DEBUG
  INFO
  WARN
  ERROR
  FATAL

  @@map("log_level")
}

// Log source enumeration
enum LogSource {
  SYSTEM
  CLAUDE
  USER
  QUEUE
  WORKER
  DATABASE

  @@map("log_source")
}

// Metric type enumeration
enum MetricType {
  COUNTER
  GAUGE
  HISTOGRAM
  SUMMARY
  TIMER

  @@map("metric_type")
}

// Result status enumeration
enum ResultStatus {
  SUCCESS
  PARTIAL_SUCCESS
  FAILURE
  ERROR
  TIMEOUT

  @@map("result_status")
}

// =============================================================================
// BACKEND TASKS API - Simplified task model for REST API operations
// =============================================================================

// Backend API Task model for simplified task management via REST API
model ApiTask {
  id          String          @id @default(uuid())
  title       String          @db.VarChar(200)
  description String?         @db.Text
  status      ApiTaskStatus   @default(TODO)
  priority    ApiTaskPriority @default(MEDIUM)
  userId      String          @map("user_id")

  // Execution metadata
  startedAt    DateTime? @map("started_at")
  completedAt  DateTime? @map("completed_at")
  failedAt     DateTime? @map("failed_at")
  errorMessage String?   @map("error_message") @db.Text

  // Logs (JSONB for flexibility)
  logs Json[] @default([])

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at") // Soft delete

  // Relations
  user User @relation("ApiTaskCreator", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([createdAt])
  @@map("api_tasks")
}

// API Task status enumeration - aligned with Task contract (Option B)
enum ApiTaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  DONE
  CANCELLED

  @@map("api_task_status")
}

// API Task priority enumeration
enum ApiTaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT

  @@map("api_task_priority")
}

// =============================================================================
// WEBSOCKET EVENT PERSISTENCE - Event replay and offline synchronization
// =============================================================================

// WebSocket event persistence for replay and offline clients
model WebSocketEvent {
  id String @id @default(uuid())

  // Event identification
  eventType     String  @map("event_type")
  correlationId String? @map("correlation_id")

  // Event routing
  room         String?
  roomType     String? @map("room_type")
  targetUserId String? @map("target_user_id")

  // Event source
  userId String @map("user_id")

  // Event payload
  eventData Json @map("event_data")

  // Replay metadata
  priority    Int     @default(0) // Higher numbers = higher priority for replay
  persisted   Boolean @default(true)
  replayed    Boolean @default(false)
  replayCount Int     @default(0) @map("replay_count")

  // Event lifecycle
  broadcastAt DateTime  @default(now()) @map("broadcast_at")
  expiresAt   DateTime? @map("expires_at")
  replayedAt  DateTime? @map("replayed_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Indexes for efficient querying
  @@index([eventType])
  @@index([userId])
  @@index([room])
  @@index([roomType])
  @@index([targetUserId])
  @@index([persisted])
  @@index([replayed])
  @@index([broadcastAt])
  @@index([expiresAt])
  @@index([priority])
  // Composite indexes for replay queries
  @@index([userId, broadcastAt])
  @@index([room, broadcastAt])
  @@index([roomType, broadcastAt])
  @@index([targetUserId, broadcastAt])
  @@index([persisted, replayed])
  @@index([replayed, broadcastAt])
  @@index([expiresAt, replayed])
  @@index([priority, broadcastAt])
  // Replay optimization indexes
  @@index([userId, persisted, replayed, broadcastAt])
  @@index([room, persisted, replayed, broadcastAt])
  @@index([targetUserId, persisted, replayed, broadcastAt])
  @@index([eventType, persisted, replayed, broadcastAt])
  @@map("websocket_events")
}

// WebSocket client connection tracking for replay
model WebSocketConnection {
  id String @id @default(uuid())

  // Connection identification
  socketId String @unique @map("socket_id")
  userId   String @map("user_id")

  // Connection metadata
  userAgent String?  @map("user_agent")
  ipAddress String?  @map("ip_address")
  rooms     String[] // Rooms this connection joined

  // Connection state
  isActive      Boolean  @default(true) @map("is_active")
  lastHeartbeat DateTime @default(now()) @map("last_heartbeat")
  lastEventAt   DateTime @default(now()) @map("last_event_at") // Last event sent to this connection

  // Replay tracking
  replayFromTime  DateTime? @map("replay_from_time") // When to start replay from (null = no replay needed)
  replayCompleted Boolean   @default(false) @map("replay_completed")

  // Timestamps
  connectedAt    DateTime  @default(now()) @map("connected_at")
  disconnectedAt DateTime? @map("disconnected_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Indexes for connection management
  @@index([socketId])
  @@index([userId])
  @@index([isActive])
  @@index([lastHeartbeat])
  @@index([lastEventAt])
  @@index([replayFromTime])
  @@index([replayCompleted])
  @@index([connectedAt])
  @@index([disconnectedAt])
  // Composite indexes for replay and cleanup
  @@index([userId, isActive])
  @@index([isActive, lastHeartbeat])
  @@index([userId, replayFromTime])
  @@index([replayCompleted, replayFromTime])
  @@index([disconnectedAt, isActive])
  @@map("websocket_connections")
}
