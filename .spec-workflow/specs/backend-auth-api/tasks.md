# Tasks - Backend Auth API

## Task Checklist

### Phase 1: Data Models & Dependencies (3 tasks)

- [x] 1. Create User and Session Prisma models
  - File: prisma/schema.prisma
  - Add User model: id (uuid), email (unique), password (bcrypt hash), name (optional), createdAt, updatedAt, deletedAt
  - Add Session model: id (uuid), userId (FK), refreshToken (unique), expiresAt, lastActive, createdAt, deletedAt
  - Add indexes: User(email), Session(userId), Session(refreshToken)
  - Add relations: User hasMany Session, Session belongsTo User (onDelete: Cascade)
  - Purpose: Define database schema for user authentication and session management
  - _Leverage: Prisma schema definition language_
  - _Requirements: 1, 2, 3, 4, 5_
  - _Prompt: Role: Database architect with Prisma expertise | Task: Create User and Session models following requirements 1-5, ensuring proper indexing for email lookups and cascading deletes | Restrictions: Do not store passwords in plain text, use proper FK constraints | Success: npx prisma format validates with no errors_

- [x] 2. Generate and apply Prisma migration
  - File: Migration generated by Prisma
  - Run: npx prisma migrate dev --name create_users_sessions
  - Validate migration file is created
  - Confirm database tables are updated
  - Purpose: Apply database schema changes to create users and sessions tables
  - _Leverage: Prisma migrations CLI_
  - _Requirements: 1, 2_
  - _Prompt: Role: DevOps engineer with database migration expertise | Task: Generate and apply Prisma migration for User and Session models following requirements 1 and 2 | Restrictions: Do not manually edit migration files, use Prisma CLI | Success: Can query users and sessions tables via Prisma Studio_

- [x] 3. Install auth dependencies
  - File: package.json
  - Run: npm install --save bcryptjs @nestjs/passport passport passport-jwt @nestjs/jwt
  - Run: npm install --save-dev @types/bcryptjs @types/passport-jwt
  - Purpose: Install required authentication libraries for JWT and password hashing
  - _Leverage: npm package manager_
  - _Requirements: 1, 2_
  - _Prompt: Role: DevOps engineer with npm expertise | Task: Install authentication dependencies for JWT and bcrypt | Restrictions: Do not install unnecessary packages, check for peer dependency warnings | Success: Dependencies installed with no peer dependency warnings_

### Phase 2: Schemas & DTOs (1 task)

- [x] 4. Define Zod schemas for auth
  - File: packages/schemas/src/auth.schema.ts, packages/schemas/src/index.ts, apps/backend/src/auth/dto/register.dto.ts, apps/backend/src/auth/dto/login.dto.ts
  - Create passwordSchema: min 8 chars, 1 uppercase, 1 number, 1 special char (regex validation)
  - Create registerSchema: email (valid email), password (passwordSchema), name (optional, max 100)
  - Create loginSchema: email, password (min 1 char, no validation for login)
  - Define JwtPayload interface: sub (userId), email, iat, exp (optional)
  - Export schemas from index.ts
  - Purpose: Define contract-driven validation schemas for authentication requests
  - _Leverage: Zod library for schema validation_
  - _Requirements: 1, 2_
  - _Prompt: Role: TypeScript developer with Zod schema expertise | Task: Define authentication Zod schemas following requirements 1 and 2, enforcing strong password policy | Restrictions: Do not weaken password requirements, enforce email validation | Success: TypeScript types generate correctly and password validation works_

### Phase 3: JWT Strategy & Guards (3 tasks)

- [x] 5. Create AuthModule with Passport integration
  - File: apps/backend/src/auth/auth.module.ts
  - Import PassportModule
  - Import JwtModule.register with secret from env and signOptions.expiresIn
  - Import PrismaModule
  - Provide: AuthService, JwtStrategy
  - Export: JwtStrategy for guards
  - Purpose: Set up authentication module with JWT and Passport integration
  - _Leverage: NestJS module system, Passport, JWT module_
  - _Requirements: 2, 6_
  - _Prompt: Role: Backend developer with NestJS and Passport expertise | Task: Create AuthModule with JWT configuration following requirements 2 and 6 | Restrictions: Do not hardcode JWT secret, use environment variables | Success: Module compiles with no errors_

- [x] 6. Implement JWT Strategy
  - File: apps/backend/src/auth/strategies/jwt.strategy.ts
  - Extend PassportStrategy(Strategy)
  - Extract JWT from Authorization header (Bearer token)
  - Use AUTH_JWT_SECRET from environment
  - Implement validate(payload): Verify user exists, verify session exists (not logged out), return user object
  - Throw UnauthorizedException if user deleted or session invalid
  - Purpose: Implement JWT token validation strategy for Passport
  - _Leverage: Passport JWT strategy, PrismaService_
  - _Requirements: 2, 6_
  - _Prompt: Role: Security engineer with JWT expertise | Task: Implement JWT strategy following requirements 2 and 6, validating both user and session existence | Restrictions: Do not skip session validation, always verify user exists | Success: Strategy validates tokens correctly and rejects invalid tokens_

- [x] 7. Create JwtAuthGuard and WsJwtGuard
  - File: apps/backend/src/auth/guards/jwt-auth.guard.ts, apps/backend/src/auth/guards/ws-jwt.guard.ts
  - JwtAuthGuard: Extend AuthGuard('jwt'), implement custom handleRequest for better error messages (TOKEN_EXPIRED, Invalid token)
  - WsJwtGuard: Implement CanActivate, extract token from WebSocket handshake, verify via JwtService, attach user to socket.data
  - Purpose: Create reusable guards for HTTP and WebSocket authentication
  - _Leverage: NestJS guards, JwtService_
  - _Requirements: 6_
  - _Prompt: Role: Backend developer with NestJS guards expertise | Task: Create JWT authentication guards for HTTP and WebSocket following requirement 6 | Restrictions: Do not expose internal errors to clients, provide user-friendly messages | Success: Guards protect routes correctly and return 401 for invalid/missing tokens_

### Phase 4: Auth Service & Controller (3 tasks)

- [x] 8. Implement AuthService (business logic)
  - File: apps/backend/src/auth/auth.service.ts
  - Implement register(dto): Check email uniqueness (409 if exists), hash password with bcrypt (10 rounds), create user, return user without password
  - Implement login(dto): Find user by email, verify password with bcrypt.compare(), generate JWT, create session, return tokens and user
  - Implement refreshToken(refreshToken): Find session, verify not expired, generate new accessToken, update session.lastActive
  - Implement logout(userId): Soft delete all active sessions for user
  - Implement findUserById(id): Get user by ID, exclude password
  - Purpose: Implement core authentication business logic with secure password handling
  - _Leverage: bcryptjs, JwtService, PrismaService_
  - _Requirements: 1, 2, 3, 4, 5_
  - _Prompt: Role: Security engineer with authentication expertise | Task: Implement AuthService following requirements 1-5, ensuring passwords are hashed with bcrypt and never leaked in responses | Restrictions: Do not return password fields, use bcrypt with 10 rounds minimum | Success: All auth operations work and passwords are never leaked_

- [x] 9. Implement AuthController (REST endpoints)
  - File: apps/backend/src/auth/auth.controller.ts
  - POST /api/auth/register: Body=RegisterDto, returns user (201 Created or 409 Conflict)
  - POST /api/auth/login: Body=LoginDto, returns accessToken, refreshToken, user (200 OK or 401)
  - POST /api/auth/refresh: Body={ refreshToken }, returns new tokens (200 OK or 401)
  - POST /api/auth/logout: Protected with @UseGuards(JwtAuthGuard), returns 204 No Content
  - GET /api/auth/me: Protected with @UseGuards(JwtAuthGuard), returns user (200 OK or 404)
  - Purpose: Expose authentication endpoints via REST API
  - _Leverage: NestJS controllers, AuthService, JwtAuthGuard_
  - _Requirements: 1, 2, 3, 4, 5_
  - _Prompt: Role: Backend API developer with NestJS expertise | Task: Implement AuthController REST endpoints following requirements 1-5, ensuring proper HTTP status codes | Restrictions: Do not expose protected endpoints without guards | Success: All endpoints return correct status codes_

- [x] 10. Apply JwtAuthGuard to protected routes
  - File: apps/backend/src/tasks/tasks.controller.ts, apps/backend/src/settings/settings.controller.ts, apps/backend/src/analytics/analytics.controller.ts
  - Add @UseGuards(JwtAuthGuard) to all TasksController routes
  - Add @UseGuards(JwtAuthGuard) to all SettingsController routes (if exists)
  - Add @UseGuards(JwtAuthGuard) to all AnalyticsController routes (if exists)
  - Extract userId from @User() decorator instead of hardcoded values
  - Purpose: Secure existing API endpoints with JWT authentication
  - _Leverage: JwtAuthGuard, @User() decorator_
  - _Requirements: 6_
  - _Prompt: Role: Backend security specialist | Task: Apply JwtAuthGuard to all protected routes following requirement 6, replacing hardcoded user IDs | Restrictions: Do not leave any endpoints unprotected that require authentication | Success: All protected routes require JWT and return 401 without token_

### Phase 5: Frontend Integration (1 task)

- [x] 11. Add auth methods to contract-client.ts
  - File: apps/frontend/src/lib/api/contract-client.ts
  - Add section comment: `// ========== Spec: backend-auth-api ==========`
  - Add register(data: RegisterDto): Promise<{ user: User }>
  - Add login(credentials: LoginDto): Promise<AuthResponseDto>
  - Add refreshToken(refreshToken: string): Promise<AuthResponseDto>
  - Add logout(): Promise<void>
  - Add getCurrentUser(): Promise<User>
  - Add HTTP interceptor to attach JWT to requests (Authorization: Bearer token)
  - Store tokens in localStorage (accessToken, refreshToken)
  - Purpose: Provide type-safe frontend authentication API client with token management
  - _Leverage: Existing contract-client.ts structure, localStorage_
  - _Requirements: 1, 2, 3, 4, 5_
  - _Prompt: Role: Frontend developer with TypeScript expertise | Task: Add authentication methods to contract-client.ts following requirements 1-5, implementing token storage and auto-attachment | Restrictions: Do not store tokens insecurely, use localStorage | Success: Frontend can call all auth methods and tokens are stored/attached correctly_

### Phase 6: Testing & Configuration (2 tasks)

- [x] 12. Create E2E tests for auth flow
  - File: apps/frontend/e2e/auth.spec.ts
  - Test: POST /api/auth/register creates user (expect 201, user object, no password field)
  - Test: POST /api/auth/register rejects duplicate email (expect 409)
  - Test: POST /api/auth/register rejects weak password (expect 400)
  - Test: POST /api/auth/login returns JWT (expect 200, accessToken, refreshToken, user)
  - Test: POST /api/auth/login rejects invalid credentials (expect 401)
  - Test: POST /api/auth/refresh renews token (expect 200, new accessToken)
  - Test: POST /api/auth/logout invalidates session (expect 204)
  - Test: GET /api/auth/me returns current user (expect 200)
  - Test: Protected routes require JWT (expect 401 without token)
  - Purpose: Validate complete authentication flow with E2E tests
  - _Leverage: Playwright for E2E testing_
  - _Requirements: 1, 2, 3, 4, 5, 6_
  - _Prompt: Role: QA engineer with E2E testing expertise | Task: Create comprehensive E2E tests for authentication following requirements 1-6, validating all success and error scenarios | Restrictions: Do not skip security tests, validate token expiration | Success: All tests pass with 0 failures_

- [x] 13. Add environment variables and register module
  - File: .env.example, apps/backend/src/main.ts
  - Add to .env.example: AUTH_API_ENABLED=true, AUTH_JWT_SECRET (min 32 chars), AUTH_JWT_EXPIRES_IN=7d, AUTH_REFRESH_EXPIRES_IN=30d, AUTH_BCRYPT_ROUNDS=10
  - Import AuthModule in backend main.ts
  - Validate JWT_SECRET length (min 32 chars) on startup
  - Purpose: Configure environment variables and register authentication module
  - _Leverage: NestJS module system, environment validation_
  - _Requirements: 1, 2_
  - _Prompt: Role: DevOps engineer with security configuration expertise | Task: Document environment variables and register AuthModule, validating JWT secret length on startup | Restrictions: Do not use weak JWT secrets, enforce minimum 32 characters | Success: Backend starts and /api/auth/login responds_

## Task Dependencies

```
Task 1 (Prisma models) → Task 2 (Migration)
                              ↓
Task 3 (Dependencies) → Task 4 (Schemas)
                              ↓
Task 5 (Module) → Task 6 (JWT Strategy) → Task 7 (Guards)
                                                ↓
Task 8 (AuthService) → Task 9 (AuthController)
                                                ↓
Task 10 (Apply guards to routes) ← Task 11 (Frontend integration)
                                                ↓
Task 12 (E2E tests) → Task 13 (Config & Deploy)
```

## Validation Checklist

Before marking this spec as complete, verify:

- [ ] All 13 tasks marked as `[x]`
- [ ] All E2E tests passing (0 failures)
- [ ] Users can register with email/password
- [ ] Users can log in and receive JWT
- [ ] JWT expires after 7 days
- [ ] Refresh token works (renews accessToken)
- [ ] Logout invalidates session
- [ ] Protected routes enforce authentication (401 without JWT)
- [ ] Settings page uses real userId from JWT (not 'current-user')
- [ ] WebSocket connections authenticate via JWT
- [ ] Passwords never leaked in responses
- [ ] Frontend stores tokens correctly (localStorage)
- [ ] No hardcoded JWT secrets (use environment variables)

## Estimated Effort

- **Total Tasks**: 13
- **Estimated Time**: 8-10 hours
- **Complexity**: High (authentication, JWT, security)
- **Dependencies**: None (foundational spec)

## Notes

- This is a foundational spec - all other backend specs depend on it
- Security is critical: Hash passwords with bcrypt, validate JWT properly, never leak passwords
- Use 10 bcrypt rounds (balance security/performance)
- JWT secret must be at least 32 characters
- Session validation prevents token reuse after logout
- Rate limit login endpoint aggressively (5 attempts per 15 min per IP)
- Consider implementing refresh token rotation for additional security
