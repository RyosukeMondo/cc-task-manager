# Tasks - Backend Settings API

## Task Checklist

### Phase 1: Data Model & Schema (2 tasks)

- [x] 1. Create Settings Prisma model with enums
  - File: prisma/schema.prisma
  - Add Settings model: id (uuid), userId (unique FK), theme (enum, default SYSTEM), notifications (boolean, default true), displayDensity (enum, default COMFORTABLE), language (string, default "en"), createdAt, updatedAt
  - Add Theme enum: LIGHT, DARK, SYSTEM
  - Add DisplayDensity enum: COMFORTABLE, COMPACT, SPACIOUS
  - Add unique constraint on userId
  - Add relation: Settings belongsTo User (onDelete: Cascade)
  - Purpose: Define database schema for user preferences and settings
  - _Leverage: Prisma schema definition language with enums_
  - _Requirements: 1, 2_
  - _Prompt: Role: Database architect with Prisma expertise | Task: Create Settings model with enums following requirements 1 and 2, ensuring unique constraint on userId and cascade delete | Restrictions: Do not allow duplicate settings per user | Success: npx prisma format validates with no errors_

- [x] 2. Generate and apply Prisma migration
  - File: Migration generated by Prisma
  - Run: npx prisma migrate dev --name create_settings
  - Validate migration file is created
  - Confirm database tables are updated
  - Purpose: Apply database schema changes to create settings table
  - _Leverage: Prisma migrations CLI_
  - _Requirements: 1_
  - _Prompt: Role: DevOps engineer with database migration expertise | Task: Generate and apply Prisma migration for Settings model following requirement 1 | Restrictions: Do not manually edit migration files | Success: Can query settings table via Prisma Studio_

### Phase 2: Module & DTOs (2 tasks)

- [ ] 3. Create SettingsModule
  - File: apps/backend/src/settings/settings.module.ts
  - Import AuthModule (provides JwtAuthGuard)
  - Import PrismaModule
  - Provide: SettingsService, SettingsRepository
  - Purpose: Set up settings module with authentication dependency
  - _Leverage: NestJS module system, AuthModule for guards_
  - _Requirements: 1, 2_
  - _Prompt: Role: Backend developer with NestJS expertise | Task: Create SettingsModule with proper DI setup following requirements 1 and 2 | Restrictions: Do not expose settings without authentication | Success: Module compiles with no errors_

- [ ] 4. Define Zod schemas for settings
  - File: packages/schemas/src/settings.schema.ts, packages/schemas/src/index.ts, apps/backend/src/settings/dto/update-settings.dto.ts
  - Create updateSettingsSchema: theme (enum: LIGHT/DARK/SYSTEM, optional), notifications (boolean, optional), displayDensity (enum: COMFORTABLE/COMPACT/SPACIOUS, optional), language (string, length 2, regex /^[a-z]{2}$/, optional)
  - Create settingsResponseSchema: all fields required (id, userId, theme, notifications, displayDensity, language, createdAt, updatedAt)
  - Export schemas from index.ts
  - Purpose: Define contract-driven validation schemas for settings API
  - _Leverage: Zod library for schema validation_
  - _Requirements: 2, 3_
  - _Prompt: Role: TypeScript developer with Zod schema expertise | Task: Define settings Zod schemas following requirements 2 and 3, enforcing enum validation and ISO 639-1 language codes | Restrictions: Do not allow invalid enum values, validate language format | Success: TypeScript types generate correctly and enum validation works_

### Phase 3: Business Logic (2 tasks)

- [ ] 5. Implement SettingsRepository
  - File: apps/backend/src/settings/settings.repository.ts
  - Implement findByUserId(userId): Get settings by userId
  - Implement create(data): Create new settings
  - Implement update(userId, data): Update existing settings
  - Implement upsert({ where, update, create }): Atomic upsert operation
  - Purpose: Implement data access layer for settings CRUD operations
  - _Leverage: Prisma Client for type-safe database operations_
  - _Requirements: 1, 2_
  - _Prompt: Role: Backend developer with Prisma expertise | Task: Implement SettingsRepository with CRUD methods following requirements 1 and 2 | Restrictions: Do not expose raw Prisma client, use repository pattern | Success: Repository methods work correctly_

- [ ] 6. Implement SettingsService (auto-create logic)
  - File: apps/backend/src/settings/settings.service.ts
  - Implement getOrCreateSettings(userId): Try findByUserId, if not found create with defaults (theme=SYSTEM, notifications=true, displayDensity=COMFORTABLE, language from env or "en")
  - Implement updateSettings(userId, dto): Use upsert to handle both create and update, merge dto with defaults for create case
  - Implement getDefaults(): Return default settings object (theme, notifications, displayDensity, language from env)
  - Purpose: Implement business logic with auto-create functionality for seamless UX
  - _Leverage: SettingsRepository, environment configuration_
  - _Requirements: 1, 2_
  - _Prompt: Role: Backend developer with service layer expertise | Task: Implement SettingsService with auto-create logic following requirements 1 and 2, using upsert to prevent race conditions | Restrictions: Do not return 404 for missing settings, auto-create instead | Success: Auto-create works on first GET and upsert prevents race conditions_

### Phase 4: HTTP API (1 task)

- [ ] 7. Implement SettingsController
  - File: apps/backend/src/settings/settings.controller.ts
  - GET /api/settings: Protected with @UseGuards(JwtAuthGuard), calls getOrCreateSettings(userId from @User()), returns 200 OK with settings (auto-creates if missing)
  - PATCH /api/settings: Protected with @UseGuards(JwtAuthGuard), body=UpdateSettingsDto, calls updateSettings(userId, dto), returns 200 OK with updated settings
  - Extract userId from JWT (not 'current-user' hardcoded value)
  - Purpose: Expose settings endpoints via REST API with auto-create functionality
  - _Leverage: NestJS controllers, JwtAuthGuard, @User() decorator_
  - _Requirements: 1, 2_
  - _Prompt: Role: Backend API developer with NestJS expertise | Task: Implement SettingsController REST endpoints following requirements 1 and 2, ensuring userId comes from JWT | Restrictions: Do not use hardcoded user IDs, always extract from JWT | Success: Endpoints return correct data and auto-create works_

### Phase 5: Frontend Integration & Testing (3 tasks)

- [ ] 8. Add settings methods to contract-client.ts
  - File: apps/frontend/src/lib/api/contract-client.ts
  - Add section comment: `// ========== Spec: backend-settings-api ==========`
  - Add getSettings(): Promise<Settings>
  - Add updateSettings(data: UpdateSettingsDto): Promise<Settings>
  - Purpose: Provide type-safe frontend API client methods for settings
  - _Leverage: Existing contract-client.ts structure_
  - _Requirements: 1, 2_
  - _Prompt: Role: Frontend developer with TypeScript expertise | Task: Add settings API methods to contract-client.ts following requirements 1 and 2 | Restrictions: Do not duplicate existing patterns | Success: Frontend can call methods without type errors_

- [ ] 9. Create E2E tests for settings API
  - File: apps/frontend/e2e/settings-api.spec.ts
  - Test: GET /api/settings auto-creates defaults on first request (expect 200, theme=SYSTEM, notifications=true)
  - Test: PATCH /api/settings updates preferences (expect 200, updated values)
  - Test: PATCH /api/settings with invalid theme returns 400 with allowed values
  - Test: PATCH /api/settings with invalid language (not ISO 639-1) returns 400
  - Test: Settings persist across sessions (logout, login, GET returns same values)
  - Test: Authentication required (401 without JWT)
  - Purpose: Validate settings API contract compliance and persistence
  - _Leverage: Playwright for E2E testing_
  - _Requirements: 1, 2, 3_
  - _Prompt: Role: QA engineer with E2E testing expertise | Task: Create comprehensive E2E tests for settings API following requirements 1, 2, and 3, validating auto-create and persistence | Restrictions: Do not skip validation tests, verify persistence | Success: All tests pass with 0 failures_

- [ ] 10. Add environment variables and register module
  - File: .env.example, apps/backend/src/main.ts
  - Add to .env.example: SETTINGS_API_ENABLED=true, SETTINGS_DEFAULT_THEME=SYSTEM, SETTINGS_DEFAULT_LANGUAGE=en, SETTINGS_DEFAULT_NOTIFICATIONS=true, SETTINGS_DEFAULT_DENSITY=COMFORTABLE
  - Import SettingsModule in backend main.ts
  - Purpose: Configure environment variables and register settings module
  - _Leverage: NestJS module system, environment configuration_
  - _Requirements: 1_
  - _Prompt: Role: DevOps engineer with configuration expertise | Task: Document environment variables and register SettingsModule following requirement 1 | Restrictions: Do not hardcode default values in code | Success: Backend starts and /api/settings responds_

## Task Dependencies

```
Task 1 (Prisma model) → Task 2 (Migration)
                             ↓
Task 3 (Module) → Task 4 (Schemas)
                             ↓
Task 5 (Repository) → Task 6 (Service with auto-create)
                                    ↓
Task 7 (Controller)
                                    ↓
Task 8 (Frontend integration)
                                    ↓
Task 9 (E2E tests) → Task 10 (Config & Deploy)
```

## Validation Checklist

Before marking this spec as complete, verify:

- [ ] All 10 tasks marked as `[x]`
- [ ] All E2E tests passing (0 failures)
- [ ] GET /api/settings auto-creates defaults (no 404)
- [ ] PATCH /api/settings updates preferences
- [ ] Settings persist across sessions
- [ ] Invalid enum values return 400 with allowed values
- [ ] Settings page uses real userId from JWT (not 'current-user')
- [ ] Frontend contract-client has all methods
- [ ] No hardcoded values (use environment variables for defaults)
- [ ] Upsert prevents race conditions for concurrent requests

## Estimated Effort

- **Total Tasks**: 10
- **Estimated Time**: 4-5 hours
- **Complexity**: Low-Medium (simple CRUD with auto-create)
- **Dependencies**: backend-auth-api (requires JwtAuthGuard)

## Notes

- Auto-create is critical for UX (no setup required for new users)
- Use Prisma upsert to prevent race conditions
- Validate enum values with Zod (return user-friendly error messages)
- Language must be ISO 639-1 code (2-letter lowercase)
- Cascade delete: When user is deleted, settings are auto-deleted
- No caching needed (settings change infrequently)
- Consider adding PATCH validation to prevent empty updates
