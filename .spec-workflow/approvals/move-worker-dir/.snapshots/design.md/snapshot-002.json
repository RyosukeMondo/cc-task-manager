{
  "id": "snapshot_1758966179478_kncw6p1pi",
  "approvalId": "approval_1758966152340_nhfj20k5a",
  "approvalTitle": "Design for moving worker to apps/worker with independent application structure",
  "version": 2,
  "timestamp": "2025-09-27T09:42:59.478Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThis design document outlines the architecture for relocating the worker implementation from `src/worker/` to `apps/worker/` to establish it as an independent application within the monorepo structure. The worker will become a standalone NestJS application dedicated to background task processing with its own package.json, build configuration, and deployment independence while maintaining seamless integration with the existing system through shared database and queue infrastructure.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n\nThe design follows documented technical patterns:\n- **NestJS 10+**: Worker maintains NestJS modular architecture with dependency injection\n- **TypeScript 5.0+**: Strict mode and type safety preserved across the application boundary\n- **BullMQ**: Job queue system remains unchanged for reliable task processing\n- **PM2 Process Management**: Worker becomes independently manageable process\n- **Prisma ORM**: Shared database access through workspace packages\n- **Docker Containerization**: Independent container build capability\n\n### Project Structure (structure.md)\n\nImplementation follows project organization conventions:\n- **Application Separation**: Worker becomes independent application under `apps/worker/`\n- **Shared Packages**: Continues using `packages/types`, `packages/schemas`, `packages/utils`\n- **Module Boundaries**: Maintains clear separation between worker and backend applications\n- **Naming Conventions**: Follows established TypeScript and file naming patterns\n- **Directory Organization**: Source code organized under `apps/worker/src/` with proper module structure\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **Configuration System**: Reuse `ConfigModule` pattern for worker-specific configuration\n- **Shared Types**: Continue using `@cc-task-manager/types` workspace package\n- **Validation Schemas**: Leverage `@cc-task-manager/schemas` for data validation\n- **Utility Functions**: Utilize `@cc-task-manager/utils` for common operations\n- **Database Models**: Access shared Prisma schema through workspace setup\n\n### Integration Points\n- **Job Queue System**: BullMQ connection remains through Redis infrastructure\n- **Database Access**: PostgreSQL connection through shared Prisma client configuration\n- **Event Communication**: Event emitter system for cross-application coordination\n- **Configuration Management**: Environment-based configuration following existing patterns\n- **Monitoring Integration**: State monitoring continues through existing logging infrastructure\n\n## Architecture\n\nThe worker application will be restructured as an independent NestJS application while maintaining architectural consistency with the overall system design.\n\n### Modular Design Principles\n- **Single Application Responsibility**: Worker handles only background job processing concerns\n- **Component Isolation**: Services remain focused on specific worker capabilities\n- **Service Layer Separation**: Clear separation between job processing, state management, and monitoring\n- **Utility Modularity**: Claude Code integration and process management as focused modules\n\n```mermaid\ngraph TD\n    A[Worker App] --> B[Worker Module]\n    B --> C[Claude Code Processor]\n    B --> D[Process Manager Service]\n    B --> E[State Monitor Service]\n    B --> F[Claude Code Client Service]\n    B --> G[Worker Service]\n\n    A --> H[Shared Packages]\n    H --> I[@cc-task-manager/types]\n    H --> J[@cc-task-manager/schemas]\n    H --> K[@cc-task-manager/utils]\n\n    A --> L[External Dependencies]\n    L --> M[Redis/BullMQ]\n    L --> N[PostgreSQL/Prisma]\n    L --> O[Python SDK Process]\n```\n\n## Components and Interfaces\n\n### Worker Application Entry Point\n- **Purpose:** Independent application bootstrap and configuration\n- **Interfaces:** NestJS application factory, configuration loading, graceful shutdown\n- **Dependencies:** ConfigModule, WorkerModule, logging infrastructure\n- **Reuses:** Existing configuration patterns, shared utilities\n\n### Worker Module\n- **Purpose:** Core dependency injection container for worker services\n- **Interfaces:** NestJS module decorator, provider exports, import management\n- **Dependencies:** BullMQ, EventEmitter, ConfigModule\n- **Reuses:** Existing module structure, configuration patterns\n\n### Claude Code Processor\n- **Purpose:** BullMQ job processor for Claude Code task execution\n- **Interfaces:** Job processing methods, error handling, progress reporting\n- **Dependencies:** ProcessManagerService, StateMonitorService, ClaudeCodeClientService\n- **Reuses:** Existing processor logic, error handling patterns\n\n### Process Manager Service\n- **Purpose:** Child process lifecycle management for Python SDK execution\n- **Interfaces:** Process spawning, monitoring, cleanup operations\n- **Dependencies:** Node.js child_process, filesystem operations\n- **Reuses:** Current process management logic, monitoring patterns\n\n### State Monitor Service\n- **Purpose:** Real-time state tracking and event emission\n- **Interfaces:** State update methods, event emission, monitoring hooks\n- **Dependencies:** EventEmitter, logging infrastructure\n- **Reuses:** Existing state tracking, event patterns\n\n### Claude Code Client Service\n- **Purpose:** Python SDK wrapper integration and communication\n- **Interfaces:** Task execution commands, result parsing, error handling\n- **Dependencies:** Process spawning, JSON communication protocols\n- **Reuses:** Current SDK integration, communication patterns\n\n### Worker Service\n- **Purpose:** High-level worker coordination and queue management\n- **Interfaces:** Public worker API, queue interaction, service orchestration\n- **Dependencies:** All worker services, BullMQ queue\n- **Reuses:** Existing service coordination, queue patterns\n\n## Data Models\n\n### Worker Configuration\n```typescript\ninterface WorkerConfig {\n  redisHost: string;\n  redisPort: number;\n  redisPassword?: string;\n  maxConcurrentJobs: number;\n  jobTimeout: number;\n  retryAttempts: number;\n  logLevel: string;\n}\n```\n\n### Job Data Structure\n```typescript\ninterface ClaudeCodeJobData {\n  taskId: string;\n  userId: string;\n  command: string;\n  arguments: Record<string, any>;\n  workingDirectory: string;\n  timeout?: number;\n  metadata?: Record<string, any>;\n}\n```\n\n### Process State Model\n```typescript\ninterface ProcessState {\n  processId: string;\n  status: 'starting' | 'running' | 'completed' | 'failed' | 'cancelled';\n  startTime: Date;\n  endTime?: Date;\n  progress: number;\n  logs: string[];\n  error?: string;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Worker Application Startup Failure**\n   - **Handling:** Graceful degradation with detailed error logging, configuration validation\n   - **User Impact:** Background job processing unavailable, clear error messages in logs\n\n2. **Job Processing Failure**\n   - **Handling:** Automatic retry with exponential backoff, error categorization, dead letter queue\n   - **User Impact:** Task marked as failed with retry information, detailed error reporting\n\n3. **Python SDK Process Crash**\n   - **Handling:** Process restart, state recovery, job re-queuing if possible\n   - **User Impact:** Transparent recovery for recoverable failures, clear error reporting for permanent failures\n\n4. **Database Connection Loss**\n   - **Handling:** Connection retry with circuit breaker pattern, job state preservation\n   - **User Impact:** Temporary processing delay, automatic recovery when connection restored\n\n5. **Redis Queue Unavailability**\n   - **Handling:** Connection retry, graceful degradation, process monitoring continuation\n   - **User Impact:** Job processing paused, automatic resumption when queue available\n\n## Testing Strategy\n\n### Unit Testing\n- **Service Testing**: Mock dependencies for isolated worker service testing\n- **Processor Testing**: Job processing logic with mocked external dependencies\n- **Configuration Testing**: Environment configuration loading and validation\n- **Error Handling Testing**: Exception scenarios and recovery mechanisms\n\n### Integration Testing\n- **Queue Integration**: BullMQ job processing with Redis backend\n- **Database Integration**: Prisma database operations through shared schemas\n- **Process Integration**: Python SDK communication and lifecycle management\n- **Event Integration**: Event emission and cross-service communication\n\n### End-to-End Testing\n- **Full Job Processing**: Complete task execution from queue to completion\n- **Error Recovery**: Failure scenarios and automatic recovery mechanisms\n- **Performance Testing**: Concurrent job processing and resource utilization\n- **Deployment Testing**: Independent application deployment and connectivity",
  "fileStats": {
    "size": 8702,
    "lines": 200,
    "lastModified": "2025-09-27T09:42:26.357Z"
  },
  "comments": []
}