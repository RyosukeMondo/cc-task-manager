{
  "id": "snapshot_1758808720481_kgp7lrxuh",
  "approvalId": "approval_1758808702474_69yz31ajq",
  "approvalTitle": "Design for Claude Code Manage - Revised with Library Details",
  "version": 3,
  "timestamp": "2025-09-25T13:58:40.481Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Claude Code Manage feature implements a minimal worker system to validate the feasibility of Claude Code SDK integration within the broader task management architecture. This design provides the foundational proof-of-concept for process spawning, monitoring, and lifecycle management of AI-powered tasks through a structured Node.js worker that interfaces with the Claude Code Python SDK.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\nThis design follows the proven technology stack from `request_and_lib_selection_without_gui.md` with specific library selections optimized for single developer productivity and AI-assisted development:\n\n**Core Framework Stack:**\n- **NestJS**: Opinionated framework with structured module/controller/service architecture for consistency and maintainability\n- **TypeScript-First**: Leveraging NestJS's first-class TypeScript support for comprehensive type safety\n- **BullMQ**: Node.js-native job queue with retry, delay, and rate limiting capabilities for robust background processing\n- **@nestjs/bullmq**: Official integration package for seamless NestJS + BullMQ integration\n\n**Process & Infrastructure Management:**\n- **PM2**: Industry-standard Node.js process manager for automatic restarts, clustering, and log management\n- **child_process.spawn**: Secure process spawning to prevent command injection vulnerabilities\n- **chokidar**: Cross-platform file system watcher for session log monitoring (more stable than fs.watch)\n\n### Project Structure (structure.md)\nThe implementation follows modular design principles aligned with the recommended stack:\n- **Service Layer**: NestJS injectable services following dependency injection patterns\n- **Configuration**: @nestjs/config for environment-based worker settings and validation\n- **Logging**: Pino for high-performance structured JSON logging throughout worker operations\n- **Validation**: Zod schemas for type-safe data validation and error prevention\n- **Utilities**: lodash-es for proven utility functions with tree-shaking optimization\n\n## Selected Libraries Implementation\n\n### Core Dependencies\n```json\n{\n  \"@nestjs/core\": \"^10.x\",\n  \"@nestjs/common\": \"^10.x\",\n  \"@nestjs/config\": \"^3.x\",\n  \"@nestjs/bullmq\": \"^10.x\",\n  \"bullmq\": \"^4.x\",\n  \"zod\": \"^3.x\",\n  \"pino\": \"^8.x\",\n  \"chokidar\": \"^3.x\",\n  \"lodash-es\": \"^4.x\"\n}\n```\n\n### Library Integration Strategy\n- **@nestjs/config**: Centralized configuration with environment validation using Zod schemas\n- **BullMQ + @nestjs/bullmq**: Task queue integration with built-in retry logic and Redis persistence\n- **Pino**: Structured logging with correlation IDs for request tracing across worker processes\n- **chokidar**: Reliable file system monitoring with cross-platform compatibility for session log detection\n- **Zod**: Runtime validation for process configurations, API requests, and external data parsing\n- **lodash-es**: Utility functions for data manipulation with tree-shaking to minimize bundle size\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **NestJS Module System**: Will extend existing application modules for worker functionality\n- **Configuration Service**: Reuse existing @nestjs/config setup for worker parameters\n- **Logging Infrastructure**: Leverage existing Pino logger configuration\n- **Database Layer**: Extend existing Prisma models for task state persistence\n\n### Integration Points\n- **BullMQ Queue System**: Integrate with existing job processing infrastructure\n- **WebSocket Gateway**: Connect to existing real-time update system for status broadcasts\n- **Database Schema**: Extend existing task tables with worker-specific fields\n- **Error Handling**: Integrate with existing structured error response patterns\n\n## Architecture\n\nThe design follows a multi-layered architecture that separates process management, monitoring, and Claude Code integration concerns:\n\n```mermaid\ngraph TD\n    subgraph \"NestJS Application\"\n        A[WorkerController] --> B[WorkerService]\n        B --> C[ProcessManager]\n        B --> D[StateMonitor]\n        B --> E[ClaudeCodeClient]\n    end\n\n    subgraph \"External Processes\"\n        F[Python Wrapper Script] --> G[Claude Code SDK]\n    end\n\n    subgraph \"Infrastructure\"\n        H[BullMQ Queue] --> I[Redis]\n        J[PostgreSQL] --> K[Task State]\n        L[File System] --> M[Session Logs]\n    end\n\n    C --> F\n    D --> L\n    D --> H\n    B --> J\n\n    style A fill:#e1f5fe\n    style F fill:#f3e5f5\n    style H fill:#e8f5e8\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each service handles one aspect (spawning, monitoring, or communication)\n- **Component Isolation**: ProcessManager, StateMonitor, and ClaudeCodeClient are independent modules\n- **Service Layer Separation**: Clear boundaries between API layer, business logic, and external integrations\n- **Utility Modularity**: Focused utilities for PID monitoring, file watching, and JSON parsing\n\n## Components and Interfaces\n\n### WorkerService\n- **Purpose:** Orchestrates Claude Code task execution and coordinates between components\n- **Interfaces:**\n  - `executeTask(taskData: TaskExecutionRequest): Promise<TaskResult>`\n  - `stopTask(taskId: string): Promise<void>`\n  - `getTaskStatus(taskId: string): Promise<TaskStatus>`\n- **Dependencies:** ProcessManager, StateMonitor, ClaudeCodeClient\n- **Reuses:** NestJS injectable patterns, existing configuration service\n\n### ProcessManager\n- **Purpose:** Handles Claude Code process spawning, lifecycle management, and signal handling\n- **Interfaces:**\n  - `spawnClaudeProcess(config: ProcessConfig): Promise<ChildProcess>`\n  - `terminateProcess(pid: number): Promise<void>`\n  - `isProcessAlive(pid: number): boolean`\n- **Dependencies:** Node.js child_process, Python wrapper script\n- **Libraries Used:**\n  - **child_process.spawn**: Secure process creation with array arguments to prevent injection\n  - **Pino logger**: Structured logging with correlation IDs for process lifecycle events\n  - **Zod**: Validation of ProcessConfig parameters before spawning\n\n### StateMonitor\n- **Purpose:** Real-time monitoring of process health, activity detection, and state transitions\n- **Interfaces:**\n  - `startMonitoring(taskId: string, pid: number): void`\n  - `stopMonitoring(taskId: string): void`\n  - `getCurrentState(taskId: string): TaskState`\n- **Dependencies:** chokidar file watcher, BullMQ for state updates\n- **Libraries Used:**\n  - **chokidar**: Cross-platform file system watcher with awaitWriteFinish for complete file updates\n  - **BullMQ**: State change notifications via job progress updates and events\n  - **lodash-es**: Utility functions for state data manipulation (debounce, throttle, etc.)\n  - **Pino**: Structured logging of all state transitions with timestamps\n\n### ClaudeCodeClient\n- **Purpose:** Abstraction layer for Claude Code SDK communication through Python wrapper\n- **Interfaces:**\n  - `sendPrompt(prompt: string, options: ClaudeOptions): void`\n  - `parseResponse(jsonOutput: string): ParsedResponse`\n  - `handleError(errorData: ErrorData): StructuredError`\n- **Dependencies:** Python wrapper script, structured JSON parsing\n- **Libraries Used:**\n  - **Zod**: Runtime validation of Claude Code responses and configuration options\n  - **Pino**: Detailed logging of all SDK interactions without exposing sensitive prompt data\n  - **lodash-es**: JSON data transformation and error handling utilities\n  - **@nestjs/config**: Access to Claude Code SDK configuration and Python executable paths\n\n### PythonWrapper (External Script)\n- **Purpose:** Bridge between Node.js worker and Claude Code Python SDK\n- **Interfaces:**\n  - Command line arguments: `--job-id`, `--session-name`, `--working-dir`\n  - stdin: JSON prompt data\n  - stdout: Structured JSON progress/result messages\n- **Dependencies:** Claude Code Python SDK, signal handling\n- **Reuses:** Standard Python logging patterns, JSON communication protocol\n\n## Data Models\n\n### TaskExecutionRequest\n```typescript\ninterface TaskExecutionRequest {\n  id: string;\n  prompt: string;\n  sessionName: string;\n  workingDirectory: string;\n  options: ClaudeCodeOptions;\n  timeoutMs?: number;\n}\n```\n\n### TaskStatus\n```typescript\nenum TaskState {\n  PENDING = 'pending',\n  RUNNING = 'running',\n  ACTIVE = 'active',\n  IDLE = 'idle',\n  COMPLETED = 'completed',\n  FAILED = 'failed',\n  CANCELLED = 'cancelled'\n}\n\ninterface TaskStatus {\n  taskId: string;\n  state: TaskState;\n  pid?: number;\n  progress?: string;\n  lastActivity: Date;\n  error?: string;\n  exitCode?: number;\n}\n```\n\n### ProcessConfig\n```typescript\ninterface ProcessConfig {\n  jobId: string;\n  sessionName: string;\n  workingDirectory: string;\n  pythonExecutable?: string;\n  wrapperScriptPath: string;\n  unbuffered: boolean;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Process Spawn Failure**\n   - **Handling:** Log error details, mark task as failed, clean up resources\n   - **User Impact:** Clear error message indicating spawn failure with diagnostic info\n\n2. **Claude Code SDK Errors**\n   - **Handling:** Parse stderr from Python wrapper, categorize error types\n   - **User Impact:** Structured error messages distinguishing SDK vs system issues\n\n3. **Process Timeout/Hang**\n   - **Handling:** SIGTERM followed by SIGKILL after grace period, mark as failed\n   - **User Impact:** Timeout notification with partial results if available\n\n4. **File System Monitoring Failure**\n   - **Handling:** Fall back to PID-only monitoring, log degraded state\n   - **User Impact:** Reduced monitoring granularity but continued operation\n\n5. **Python Wrapper Crash**\n   - **Handling:** Capture exit code and stderr, attempt automatic recovery\n   - **User Impact:** Detailed crash report with recovery options\n\n## Testing Strategy\n\n### Unit Testing\n- **ProcessManager**: Mock child_process.spawn, test signal handling and PID management\n- **StateMonitor**: Mock file system events, test state transition logic\n- **ClaudeCodeClient**: Mock Python wrapper responses, test JSON parsing accuracy\n- **WorkerService**: Mock all dependencies, test orchestration and error propagation\n\n### Integration Testing\n- **Process Lifecycle**: Full spawn-to-completion cycles with real Python wrapper\n- **Monitoring System**: File system changes triggering correct state updates\n- **Error Recovery**: Intentional failures to validate recovery mechanisms\n- **Signal Handling**: SIGTERM/SIGKILL scenarios with graceful shutdown testing\n\n### End-to-End Testing\n- **Complete Task Execution**: Real Claude Code SDK integration with sample tasks\n- **Multi-task Concurrency**: Multiple workers handling different tasks simultaneously\n- **Failure Scenarios**: Network issues, process crashes, and recovery validation\n- **Performance Testing**: Resource usage monitoring under sustained load",
  "fileStats": {
    "size": 10775,
    "lines": 257,
    "lastModified": "2025-09-25T13:58:15.421Z"
  },
  "comments": []
}