{
  "id": "snapshot_1758808490378_lztlvj1mj",
  "approvalId": "approval_1758808490368_bcnoxqael",
  "approvalTitle": "Design for Claude Code Manage - Worker System Architecture",
  "version": 1,
  "timestamp": "2025-09-25T13:54:50.378Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nThe Claude Code Manage feature implements a minimal worker system to validate the feasibility of Claude Code SDK integration within the broader task management architecture. This design provides the foundational proof-of-concept for process spawning, monitoring, and lifecycle management of AI-powered tasks through a structured Node.js worker that interfaces with the Claude Code Python SDK.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\nThis design follows the NestJS + TypeScript backend architecture with BullMQ for job processing as specified in the steering document. The implementation leverages:\n- **NestJS Framework**: Structured service and module architecture for worker management\n- **BullMQ Integration**: Job queue system for task lifecycle management\n- **TypeScript First**: Strong typing throughout the worker and monitoring systems\n- **Process Management**: PM2 supervision as outlined in the production strategy\n\n### Project Structure (structure.md)\nThe implementation follows modular design principles with clear separation of concerns:\n- **Service Layer**: Worker services isolated from API controllers\n- **Utility Modules**: Process monitoring and Claude Code integration utilities\n- **Configuration Management**: Environment-based settings for worker behavior\n- **Error Handling**: Structured error propagation aligned with neverthrow patterns\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **NestJS Module System**: Will extend existing application modules for worker functionality\n- **Configuration Service**: Reuse existing @nestjs/config setup for worker parameters\n- **Logging Infrastructure**: Leverage existing Pino logger configuration\n- **Database Layer**: Extend existing Prisma models for task state persistence\n\n### Integration Points\n- **BullMQ Queue System**: Integrate with existing job processing infrastructure\n- **WebSocket Gateway**: Connect to existing real-time update system for status broadcasts\n- **Database Schema**: Extend existing task tables with worker-specific fields\n- **Error Handling**: Integrate with existing structured error response patterns\n\n## Architecture\n\nThe design follows a multi-layered architecture that separates process management, monitoring, and Claude Code integration concerns:\n\n```mermaid\ngraph TD\n    subgraph \"NestJS Application\"\n        A[WorkerController] --> B[WorkerService]\n        B --> C[ProcessManager]\n        B --> D[StateMonitor]\n        B --> E[ClaudeCodeClient]\n    end\n\n    subgraph \"External Processes\"\n        F[Python Wrapper Script] --> G[Claude Code SDK]\n    end\n\n    subgraph \"Infrastructure\"\n        H[BullMQ Queue] --> I[Redis]\n        J[PostgreSQL] --> K[Task State]\n        L[File System] --> M[Session Logs]\n    end\n\n    C --> F\n    D --> L\n    D --> H\n    B --> J\n\n    style A fill:#e1f5fe\n    style F fill:#f3e5f5\n    style H fill:#e8f5e8\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Each service handles one aspect (spawning, monitoring, or communication)\n- **Component Isolation**: ProcessManager, StateMonitor, and ClaudeCodeClient are independent modules\n- **Service Layer Separation**: Clear boundaries between API layer, business logic, and external integrations\n- **Utility Modularity**: Focused utilities for PID monitoring, file watching, and JSON parsing\n\n## Components and Interfaces\n\n### WorkerService\n- **Purpose:** Orchestrates Claude Code task execution and coordinates between components\n- **Interfaces:**\n  - `executeTask(taskData: TaskExecutionRequest): Promise<TaskResult>`\n  - `stopTask(taskId: string): Promise<void>`\n  - `getTaskStatus(taskId: string): Promise<TaskStatus>`\n- **Dependencies:** ProcessManager, StateMonitor, ClaudeCodeClient\n- **Reuses:** NestJS injectable patterns, existing configuration service\n\n### ProcessManager\n- **Purpose:** Handles Claude Code process spawning, lifecycle management, and signal handling\n- **Interfaces:**\n  - `spawnClaudeProcess(config: ProcessConfig): Promise<ChildProcess>`\n  - `terminateProcess(pid: number): Promise<void>`\n  - `isProcessAlive(pid: number): boolean`\n- **Dependencies:** Node.js child_process, Python wrapper script\n- **Reuses:** Existing logging infrastructure, error handling patterns\n\n### StateMonitor\n- **Purpose:** Real-time monitoring of process health, activity detection, and state transitions\n- **Interfaces:**\n  - `startMonitoring(taskId: string, pid: number): void`\n  - `stopMonitoring(taskId: string): void`\n  - `getCurrentState(taskId: string): TaskState`\n- **Dependencies:** chokidar file watcher, BullMQ for state updates\n- **Reuses:** WebSocket gateway for real-time updates, existing timer utilities\n\n### ClaudeCodeClient\n- **Purpose:** Abstraction layer for Claude Code SDK communication through Python wrapper\n- **Interfaces:**\n  - `sendPrompt(prompt: string, options: ClaudeOptions): void`\n  - `parseResponse(jsonOutput: string): ParsedResponse`\n  - `handleError(errorData: ErrorData): StructuredError`\n- **Dependencies:** Python wrapper script, structured JSON parsing\n- **Reuses:** Zod schemas for validation, existing API response patterns\n\n### PythonWrapper (External Script)\n- **Purpose:** Bridge between Node.js worker and Claude Code Python SDK\n- **Interfaces:**\n  - Command line arguments: `--job-id`, `--session-name`, `--working-dir`\n  - stdin: JSON prompt data\n  - stdout: Structured JSON progress/result messages\n- **Dependencies:** Claude Code Python SDK, signal handling\n- **Reuses:** Standard Python logging patterns, JSON communication protocol\n\n## Data Models\n\n### TaskExecutionRequest\n```typescript\ninterface TaskExecutionRequest {\n  id: string;\n  prompt: string;\n  sessionName: string;\n  workingDirectory: string;\n  options: ClaudeCodeOptions;\n  timeoutMs?: number;\n}\n```\n\n### TaskStatus\n```typescript\nenum TaskState {\n  PENDING = 'pending',\n  RUNNING = 'running',\n  ACTIVE = 'active',\n  IDLE = 'idle',\n  COMPLETED = 'completed',\n  FAILED = 'failed',\n  CANCELLED = 'cancelled'\n}\n\ninterface TaskStatus {\n  taskId: string;\n  state: TaskState;\n  pid?: number;\n  progress?: string;\n  lastActivity: Date;\n  error?: string;\n  exitCode?: number;\n}\n```\n\n### ProcessConfig\n```typescript\ninterface ProcessConfig {\n  jobId: string;\n  sessionName: string;\n  workingDirectory: string;\n  pythonExecutable?: string;\n  wrapperScriptPath: string;\n  unbuffered: boolean;\n}\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Process Spawn Failure**\n   - **Handling:** Log error details, mark task as failed, clean up resources\n   - **User Impact:** Clear error message indicating spawn failure with diagnostic info\n\n2. **Claude Code SDK Errors**\n   - **Handling:** Parse stderr from Python wrapper, categorize error types\n   - **User Impact:** Structured error messages distinguishing SDK vs system issues\n\n3. **Process Timeout/Hang**\n   - **Handling:** SIGTERM followed by SIGKILL after grace period, mark as failed\n   - **User Impact:** Timeout notification with partial results if available\n\n4. **File System Monitoring Failure**\n   - **Handling:** Fall back to PID-only monitoring, log degraded state\n   - **User Impact:** Reduced monitoring granularity but continued operation\n\n5. **Python Wrapper Crash**\n   - **Handling:** Capture exit code and stderr, attempt automatic recovery\n   - **User Impact:** Detailed crash report with recovery options\n\n## Testing Strategy\n\n### Unit Testing\n- **ProcessManager**: Mock child_process.spawn, test signal handling and PID management\n- **StateMonitor**: Mock file system events, test state transition logic\n- **ClaudeCodeClient**: Mock Python wrapper responses, test JSON parsing accuracy\n- **WorkerService**: Mock all dependencies, test orchestration and error propagation\n\n### Integration Testing\n- **Process Lifecycle**: Full spawn-to-completion cycles with real Python wrapper\n- **Monitoring System**: File system changes triggering correct state updates\n- **Error Recovery**: Intentional failures to validate recovery mechanisms\n- **Signal Handling**: SIGTERM/SIGKILL scenarios with graceful shutdown testing\n\n### End-to-End Testing\n- **Complete Task Execution**: Real Claude Code SDK integration with sample tasks\n- **Multi-task Concurrency**: Multiple workers handling different tasks simultaneously\n- **Failure Scenarios**: Network issues, process crashes, and recovery validation\n- **Performance Testing**: Resource usage monitoring under sustained load",
  "fileStats": {
    "size": 8406,
    "lines": 213,
    "lastModified": "2025-09-25T13:54:44.658Z"
  },
  "comments": []
}